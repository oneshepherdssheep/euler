<a id="top"></a>
# Project Euler

My solutions to the euler project challenges (https://projecteuler.net) implemented in C++

**Contents**<br>
[Challenge 1 : Multiples of 3 or 5](Multiples-of-3-or-5)<br>
[Challenge 2 : Even fibonacci numbers](Even-fibonacci-numbers)<br>

## Challenge 1 : Multiples of 3 or 5

### Description
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.<br>
The sum of these multiples is 23.<br>

Find the sum of all the multiples of 3 or 5 below 1000.

### Understanding 

The goal here is to compute the sum of all natural numbers below 1000 which are multiples of 3 or 5.
It is only mentionned 3 or 5 so it means that we should avoid numbers which are multiples of both like 15.

So if we compute the sum of numbers *only* multiple of 3 (S3), then those *only* multiple of 5(S5) and finally
the sum of numbers *only* multiple of 15 (S15) and then compute the *S = (S3+S5)-S15*, we should have the
expected value.

## Challenge 2 : Even fibonacci numbers

### Description

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:<br>
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br>
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.<br>

### Understanding

For this one, we have to compute the Fibonacci numbers which are less than four million,<br>
for each one of them find out if they are even and if it is the case perform a summation.<br>

That's not so difficult, but the difficulty resides in the computation of Fibonacci numbers. <br>
Usually we use recursive function to do that. However, if we have to do that for all numbers, <br>
it will have a huge cost.

The first solution which came to my mind was to have a caching system so that as we are computing <br>
Fibonacci numbers, we may cache them along the way, so that the recursive function could use some <br>
cached values instead of always going to a recursive branch which may have been explored already <br>
for another computation. <br>
